---
title: MQ队列学习
author: wangdyyy
tags: 学习笔记
categories:
  - 技术笔记
date: 2024-06-13 17:28:39
---



## 定义

消息队列（Message Queue），本质上是一个队列，先进先出，但是队列中存储的内容是消息。

## 作用
用于解耦，两个不同的程序直接，如果需要通信的话，可以根据实际情况使用MQ。

两个进程A、B需要通信，如果直接采用调用的方式，A、B耦合太高，如果他们的通讯还设计到时间顺序问题，耦合会更复杂。我自己写了一个油猴脚本，就是这样涉及到两个页面通讯问题，页面2工作结束后需要给页面1发送消息，然后进行下一步操作。我最开始是设置的定时任务，但是由于作业时长不一致，会导致出现莫名的错误。这个问题也不一定要用MQ，可以用设计模式，比如：发布-订阅;可以使用监听本地存储。

## RabbitMQ基本概念
- 消息队列
    - 一个FIFO的数据结构，用于存储处理的消息。主要目的是解耦生产和消费的速度差异，提高系统的异步处理能i和弹性。
- 生产者
    - 生成消息并将消息发送到消息队列的程序和服务，不关心谁处理，只复制消息的产生和发送。
- 消费者
  - 从消息队列中接收并处理消息的程序或服务。一个消息可以北单个消费者消费，也可以被多个消费者以不同的方式处理。
- 交换器
  - 交换器是RabbitMQ中的一个核心组件，负责接收生产者发送的消息，根据路由规则投递到一个或多个队列中。生产者再发送消息时，会指定一个交换器和一个Routing Key，交换器根据Routing Key决定如何处理消息。
- 绑定
  - 绑定是建立交换器和队列之间关系的过程。通过绑定，可以指定某个交换器接收的消息应该被路由到哪个队列，是实现消息路由灵活性的关键机制。

## 什么情况可以使用

1.高并发的流量削峰

2.应用解耦

3.异步处理

4.分布式事务

5.数据分发



## RabbitMQ安装、启动问题


在windows上安装，报错：
```
BOOT FAILED
===========
ERROR: could not bind to distribution port 25672, it is in use by another node: rabbit
```

问题原因：

windows手动安装RabbitMQ,会自动在windows“服务和应用程序”中启动RabbitMQ服务，需要在“服务和应用程序”，把RabbitMQ服务修改成手动启动，并把服务停掉，用命令行启动该服务。

## RabbitMQ工作模式
- Simple模式
  - 主要涉及三个核心组件：生产者、队列和消费者
  - 队列声明： 在消息开始流动前，通常需要先声明队列。这一步骤定义了队列的名称和一些属性（如是否持久化）。
  - 消息发送： 生产者通过连接到RabbitMQ服务器，并使用默认的交换器（通常为default交换器）发送消息。在发送消息时，生产者会指定一个routing_key，在Simple模式中，这个routing_key通常与队列的名称相同，这样消息就能精确地路由到指定的队列。
  - 消息接收： 消费者连接到RabbitMQ，并指定要监听的队列。RabbitMQ根据预设的分配策略（如轮询）将队列中的消息分发给消费者。默认情况下，消息只会被一个消费者接收并处理，除非设置了特殊的消息分发模式。
- Work模式
  - “竞争消费者模式”或“任务分发模式”，是一种设计用来高效分配和处理大量任务的模式。比Simple模式多了一个“消息竞争与分配”
  - 队列创建: 首先，需要在RabbitMQ中声明一个队列，用于存放所有待处理的任务消息。
  - 消费者注册: 多个消费者连接到RabbitMQ服务器，并各自声明它们将从特定的队列中接收消息。所有消费者都关注同一个队列。
  - 消息发送: 生产者将任务作为消息发送到上述队列中。RabbitMQ确保消息的有序性和可靠性。
  - 消息分配: RabbitMQ会根据预设的分配策略，将队列中的消息公平地分发给各个消费者。默认情况下，采用轮询的方式，即每次将消息分配给尚未处理消息或最近处理完消息的消费者，以此达到负载均衡。
  - 消息确认: 消费者处理完消息后，会向RabbitMQ发送一个确认，表明消息已被成功处理。RabbitMQ收到确认后，会将该消息从队列中移除。如果消费者未能处理消息（例如崩溃），RabbitMQ可以根据配置重新分发该消息。
- Publish模式
- Routing模式
- Topic模式