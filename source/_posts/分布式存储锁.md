---
title: 分布式存储锁
author: wangdyyy
date: 2024-06-13 09:09:13
tags: 学习笔记
categories:
- 技术笔记
---

# <center> 分布式存储锁

## 什么是分布式存储锁
分布式锁是一种在分布式系统中协调多个进程活服务对共享资源访问的同步机制。它主要用于防止多个分布式节点同时操作同一份共享资源而导致的数据不一致、冲突或损坏。

个人理解：在分布式环境中多个用户来读写同一个数据，会产生脏数据。分布式存储锁是用来保证数据一致的数据锁。

## 几种常见的分布式存储锁的类型

* 一、基于数据库
    - 基于MySQL表唯一索引
        - 原理： 表增加唯一索引；加锁，执行insert语句，若报错，则表明加所失败；解锁，执行delete命令。
    - 基于MongoDB的findAndModify原子操作
      - 原理：加锁，执行findAnyModify原子命令查找document，若不存在则新增；解锁，删除document。
* 二、基于缓存
    - 基于Redis命令
      - 原理：加锁，执行setnx，若成功在执行expire添加过期时间；解锁，执行delete命令。
* 三、基于分布式协调系统
  - 基于ZooKeeper
    - 原理：加锁，在/lock目录下创建临时有序节点，判断创建的节点是否最小。若是，则表示获取到锁，否则Watch /lock目录序号比自身小的前一个节点；解锁，删除节点。

## 分布式存储锁的优缺点

* 基于数据库唯一索引
 - 优点：利用数据库实现，实现简单。
 - 缺点：
   - 1.无超时失效机制，有死锁风险。
   - 2.不支持锁重入，不支持阻塞等待。
   - 3.操作数据库开销大，性能不高。

* 基于Redis实现
  - 优点：
    - 实现简单
    - 与数据库实现方式相比，性能较高
  - 缺点：
    - 不支持阻塞等待、不可重入
    - setnx和expire分2步执行，非原子操作；若setnx执行成功，但expire执行失败，就可能出现死锁。
    - delete命令存在误删除非当前线程持有的锁。


## 死锁示例

* 基于数据库唯一索引实现的死锁
使用一张表作为锁服务。
```
CREATE TABLE `distributed_lock` (
    `lock_id` INT NOT NULL,
    `lock_key` VARCHAR(64) NOT NULL,
    `acquired_at` TIMESTAMP NULL,
    PRIMARY KEY (`lock_id`),
    UNIQUE KEY `uk_lock_key` (`lock_key`) -- 唯一索引，用于确保同一时刻只有一个进程能获取到锁
) ENGINE=InnoDB;
```
有A、B两个事务，A先执行，在A执行之后，但事务锁未完成B马上执行。这样会导致，A、B互相等待释放锁。形成死锁。

* 基于Redis命令的死锁


有两个事务A、B调用同一资源,在A执行setnx后，执行完事务之后发生断网，没有立刻释放锁，事务锁超时后自动释放。B事务开始，执行setnx,事务还未执行结束，此时A网络恢复正常，发出释放锁的命令,B事务的锁就破异常释放，这时资源就会发生脏数据。

## 死锁解决方案

* 基于数据库唯一索引实现的死锁解决方案
  - 使用悲观锁、乐观锁策略。悲观锁的思路可以体现在对分布式锁的严格控制上，即在操作资源前，必须先获取锁。应用乐观锁时，通常不直接在获取资源前加锁，而是通过版本控制或其他机制来检测并发修改。
  - 设置更短的事务执行时间

* 基于Redis实现的死锁
  - 使用Lua脚本实现原子操作
  - 使用一致性哈希算法：一种将数据根据哈希值分布到多个节点的算法，可以保证在节点增减或者网络故障情况下，一定程度保证数据一致性。